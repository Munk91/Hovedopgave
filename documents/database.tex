\section{Database}
Vi har i vores system valgt, at bruge to forskellige databaser, hvoraf de også er forskellige typer.
\\
Vi har været vant til fra studiet at bruge relationelle databaser, som bruger SQL. Dog har vi i dette projekt 
forsøgt os med et alternativ, da vi har valgt at bruge ElasticSearch til at indeksere data.
Samtidig har vi anvendt en MySQL database til at håndtere data der ikke var så indholdsrigt.
\subsection{Valg af database}
Vores valg stod primært mellem MySQL, MongoDB og ElasticSearch. Grunden til dette er, at de anvender strukturer og
kompabilitet med den type teknologier vi anvender. Derudover havde vi en ekstern MySQL database til rådighed, som vi valgte at anvende.
\\\\
I vores situation, hvor vi har anvendt PHP til vores backend, giver MySQL rigtig god mening, da det er let integrerbart med PHP.
\\\\
Vores valg faldt på at anvende både MySQL og ElasticSearch.
\\
Vi valgte at bruge MySQL da vi har noget nødvendig data, som skal gemmes. Når man uploader et API giver det god mening
for os, at disse data bliver gemt på en MySQL database, så vi dermed kan pulle data fra det gemte API, når vi har behov for det.\\
Vi har desuden også en ekstern MySQL database til rådighed som vi allerede betalte for inden projektperioden, ellers ville vi have anvendt MariaDB, da det er en fork af MySQL, 
der giver de samme funktionaliter som en fuld MySQL database, den er bare helt gratis.
\\\\
Grunden til at vi valgte at bruge ElasticSearch til at gemme data, var at vi forventede at skulle håndtere store datamængder.
Disse data ville være indholdet af det statistik data vi hentede ind fra API endpoints.
\\
Hvor en relationel database ville kræve at vi lavede et SQL kald, hvor vi skulle joine en masse data sammen, har man i ElasticSearch
bedre mulighed for at søge og udvælge data på en hurtig og effektiv måde.
\\
Meget af grunden bundede derfor i et performance boost til systemet, i form af hurtigere at kunne servere den nødvendige data.
\\
ElasticSearch er primært lavet til at indexere, søge og hente data meget effektivt og vinder derfor klart på performance ift.\ relationelle databaser.
Dog skal det nævnes at ElasticSearch ikke er en decideret database. Vi har anvendt teknologien til blandt andet at gemme og hente data.\\
\\
Der hvor ElasticSearch taber sammenlignet med andre databaser, er at det oprindeligt er lavet som en search engine.
\\Man får ikke den samme sikkerhed og struktur, som de andre tilbyder, ved at benytte ElasticSearch
\subsection{Normalisering}
Når vi gemmer informationer omkring API'er, gemmer vi dem i en tabel der hedder \textit{Apis}. Denne tabel indeholder kolonnerne: Id, Index, Type og URL.
\\\\
Data i tabel~\ref{table:api-tabel} er kun et eksempel, og er ikke en reel kopi af den originale tabel.
\begin{table}[H]
    \centering
    \begin{tabular}{|l|l|l|l|l}
        \cline{1-4}
        id & index  &  type &  url &  \\ \cline{1-4}
        1 & Ordbogen & antal\_søgninger\_2011 & http://ordbogen.com/api/searches\_year\_2011 &  \\ \cline{1-4}
        2 & Ordbogen & antal\_søgninger\_2012 & http://ordbogen.com/api/searches\_year\_2012 &  \\ \cline{1-4}
        3 & Ordbogen & antal\_søgninger\_2013 & http://ordbogen.com/api/searches\_year\_2013 &  \\ \cline{1-4}
    \end{tabular}
    \caption{Apis tabel}
    \label{table:api-tabel}
\end{table}

I vores overvejelser omkring normalisering har vi tænkt over hvorvidt denne tabel skal følge alle normalformer (0-3).
\\
Der opstår dog problemer ved 3. normalform som siger at \textit{"3NF kræver, at et felt \textbf{kun} er afhængig af primærnøglen.
Selvom alle felterne i en tabel overholder 2NF eller at primærnøglen slet ikke er sammensat, så kan der være tilfælde, hvor indholdet af et felt kan bestemmes alene udfra et andet felt i tabellen, som ikke selv er en del af primærnøglen."}\footnote{http://www.eksperten.dk/guide/234}
\\\\
Hvis vi kigger på tabel~\ref{table:api-tabel} kan url'en udledes ud fra typen, da disse to felter er unikke. Det samme gælder for typen der kan udledes fra url'en.
\\
En løsning på dette ville være at lave endnu en tabel med type og url, samt en fremmednøgle med relation fra \textit{Apis} tabellen til denne nye tabel, så et id og index peger på en fremmednøgle i tabellen med type og url.
\\\\
Grunden til vi ikke valgte denne løsning var at vi synes det var for meget arbejde i forhold til hvad det ville give os.
\\
Vi vurderede i dette tilfælde at data strukturen var så simpel at det ikke gav mening at ofre tid for pænere struktur i form af at opfylde 3. normalform, men at vente med at opdele tabellen til hvis der kom flere kolonner.
